Bradley MontUID: 804-993-030Professor SmallbergCS 31, Lecture 1, Discussion 1DProgramming Assignment 3: Keyboard Codinga. One notable obstacle that I overcame was keeping track of my code and where my errors were coming from when there was so much packed into one function. My hasCorrectSyntax was originally extremely dense and confusing, so I overcame that obstacle by separating it into an isCorrectNoteSyntax function and an isCorrectBeatSyntax function. The code was much clearer that way. Additionally, my program originally would not encode the last note in every beat. In order to avoid going out of bounds in my for loop, I had a separate statement below my for loop (that went through the beat) to encode the last note because the loop missed it. Another obstacle I overcame was outputting the ASCII value for the int octave parameter of encodeNote. I kept wondering why I would get the 50th octave, but I realized it was outputting the ASCII value of the number instead of the actual number. I subtracted 48 to convert from ASCII value to actual string value. b. For my program, I decided to delegate a lot of the code for hasCorrectSyntax into 2 functions called isCorrectNoteSyntax and isCorrectBeatSyntax. The isCorrectNoteSyntax function receives a string note as a parameter, and it returns true if it is a syntactically correct note, and it returns false if it is not. The isCorrectBeatSyntax function first checks to see if the given beat is an empty string (which is valid). Then, it divides the given beat into notes and runs isCorrectNoteSyntax on each note. It returns true if the beat consists of only syntactically correct notes. My hasCorrectSyntax function divided the given song into beats and then ran isCorrectBeatSyntax for each beat. I overrode song as its substring from after the current beat until the end so I could advance through each beat of the string. If I went through all of the beats without returning false and was left with an empty string, then I returned true. For encodeSong, I again divided the song into beats and then into notes (after checking if the song is valid with hasCorrectSyntax); then, based on the note's size, I encoded each note and added the encoding to my tempInstructions string that I would later set to instructions at the end. Plus, I had a beatCounter so I could return which beat was the "badBeat." Also, I had a noteCounter to see if brackets or spaces was needed. Pseudocode:isCorrectNoteSyntax(string note){      check if the note begins with A-G            if the note's length is 1      return true            if the note's length is 2      	return if the note is followed by an accidental or digit      if the note's length is 3      	return if the 2nd character is an accidental and the 3rd character is a digit            return false otherwise}isCorrectBeatSyntax(){	return true if the beat is an empty string	return false if the beat doesn't begin with A-G	repeatedly:		check for an uppercase letter to divide the beat into notes			go through each note and return false if any notes are invalid		return true if no notes are invalid}hasCorrectSyntax(){	repeatedly:		divide the song into beats			return false if any beats are invalid	return true if the song is valid (all the beats are valid)}encodeSong(){	check if the string has correct syntax	repeatedly:		divide the song into beats and go through each beat			within each beat, divide it into notes and encode each note				check for bad beats at the end of each beat				insert spaces or brackets depending on the number of notes in each beat}c. Test data:"" Ð empty string"/" Ð one empty beat"///" Ð multiple empty beats"A/" Ð one single note beat"Ab/" Ð one single note beat with accidental"A3/" Ð one single note beat with octave"Ab3/" Ð one single note beat with accidental and octave"A9/" Ð one bad beat"A#9/" Ð one bad beat with accidental"A/B/" Ð 2 single note beats"ABFG/" Ð 1 multiple note beat"AF/GD/" Ð 2 multiple note beats"A" Ð single note without ending /"J/" Ð note outside of A-G"a/" Ð lowercase note"A /" Ð spaces within a beat"#/" Ð missing letter note"C#2/" Ð unplayable note"4/" Ð octave digit without a letter"Bb1/" Ð only valid octave 1 note"D3/F#3/A///" Ð each type of correct note"BABBA/" Ð same note multiple times in a chord