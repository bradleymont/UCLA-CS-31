Bradley MontUID: 804-993-030Professor SmallbergCS 31, Lecture 1, Discussion 1DProgramming Assignment 4: Array of Sunshinea. One of the notable obstacles that I overcame was figuring out how each function handles n being zero. For example, appendToAll just appended the value to zero elements so it wasn't a problem; however, for positionOfMax, I had to return a -1 for a zero parameter because it doesn't make sense to find the largest string out of zero elements. Additionally, for rotateLeft, the value before pos kept getting copied into pos, until I figured out that I should save the value at pos before iterating through the array, and then I put that saved value in the last position after I went through the array and rotated left. Finally, for split, my function would always miss a value that was less than splitter followed by a value greater than splitter. This was because when I rotated left, the values would go back one, so I would skip whatever came directly after rotating right. I fixed this by using two ifs instead of an else if, and also by putting rotateLeft before the rotate Right. b. Test Data:int appendToAll(string a[], int n, string value)(a[3] = {"Apple", "Banana", "Orange"}, -1, "?") - negative value for n(a[3] = {"Apple", "Banana", "Orange"}, 0, "?") - zero value for n(a[3] = {"Apple", "Banana", "Orange"}, 2, "") - appending empty string(a[3] = {"", "", ""}, 1, "?") - array containing empty strings(a[0] = {}, -1, "?") - empty array(a[3] = {"Apple", "Banana", "Orange"}, 2, "?") - n less than size of the array(a[3] = {"Apple", "Banana", "Orange"}, 3, "?") - n equal to size of the array(a[3] = {"Apple", "Apple", "Apple"}, 2, "?") - array contains same values(a[3] = {"Apple", "Banana", "Orange"}, 4, "?") - n greater than size of the array (program doesn't account for this)int lookup(const string a[], int n, string target)(a[3] = {"Apple", "Banana", "Orange"}, -1, "?") - negative value for n, target not in array(a[3] = {"Apple", "Banana", "Orange"}, -1, "Apple") - negative value for n, target in array(a[3] = {"Apple", "Banana", "Orange"}, 0, "?") - zero value for n, target not in array(a[3] = {"Apple", "Banana", "Orange"}, 0, "Apple") - zero value for n, target in array(a[3] = {"Apple", "Banana", "Orange"}, 3, "Apple") - n equal to size of array, target in array(a[3] = {"Apple", "Banana", "Orange"}, 3, "?") - n equal to size of array, target not in array(a[3] = {"Apple", "Banana", "Orange"}, 2, "Apple") - n less than size of array, target in array(a[3] = {"Apple", "Banana", "Orange"}, 3, "?") - n less than size of array, target not in array(a[3] = {"Apple", "Apple", "Orange"}, 3, "Apple") - multiple values matching target(a[3] = {"Apple", "Apple", "Apple"}, 3, "Apple") - all values matching target(a[3] = {"Apple", "Banana", "Orange"}, 2, "Orange") - target outside of range of n(a[3] = {"", "", ""}, 1, "") - array containing empty strings, target also empty string(a[3] = {"", "", ""}, 1, "?") - array containing empty strings, target not empty string(a[3] = {"Apple", "Banana", "Orange"}, 2, "") - empty string target(a[3] = {"Apple", "Banana", "Orange"}, 4, "Orange") - n larger than array size (my code does not account for this)(a[0] = {}, 0, "?") - empty arrayint positionOfMax(const string a[], int n)(a[3] = {"Apple", "Banana", "Orange"}, -1) - negative value for n(a[3] = {"Apple", "Banana", "Orange"}, 0) - 0 value for n(a[3] = {"Apple", "Banana", "Orange"}, 2) - n less than size of the array(a[3] = {"Apple", "Banana", "Orange"}, 3) - n equal to size of the array(a[3] = {"Apple", "Banana", "Orange"}, 4) - n greater than size of the array (code doesn't account for this)(a[3] = {"Apple", "Banana", "Orange"}, 2) - n less than size of the array(a[3] = {"", "Banana", "Orange"}, 2) - array contains an empty string(a[3] = {"", "", ""}, 2) - array of all empty strings(a[0] = {}, 0) - empty array(a[3] = {"Apple", "Orange", "Orange"}, 3) - multiple maxes(a[3] = {"Orange", "Orange", "Orange"}, 3) - no max (or all maxes)int rotateLeft(string a[], int n, int pos)(a[3] = {"Apple", "Banana", "Orange"}, -1, -1) - n and pos both negative(a[3] = {"Apple", "Banana", "Orange"}, 2, -1) - pos negative(a[3] = {"Apple", "Banana", "Orange"}, -2, 2) - n negative(a[3] = {"Apple", "Banana", "Orange"}, 0, 0) - pos and n zero(a[3] = {"Apple", "Banana", "Orange"}, 2, 0) - pos zero(a[3] = {"Apple", "Banana", "Orange"}, 0, 2) - n zero(a[3] = {"Apple", "Banana", "Orange"}, 2, 1) - n less than size of the array(a[3] = {"Apple", "Banana", "Orange"}, 3, 1) - n equal to size of the array (pos < n)(a[3] = {"Apple", "Banana", "Orange"}, 4, 1) - n greater than size of the array(a[3] = {"Apple", "Banana", "Orange"}, 2, 1) - n equal to size of the array(a[3] = {"Apple", "Banana", "Orange"}, 1, 2) - pos greater than or equal to n(a[3] = {"Apple", "Banana", "Orange"}, 3, 2) - pos equal to final position (n - 1)(a[0] = {}, 0, 0) - empty array(a[3] = {"", "", ""}, 2, 1) - array of all empty strings(a[1] = {"Apple"}, 1, 0) - 1 value arrayint countRuns(const string a[], int n)(a[3] = {"Apple", "Banana", "Orange"}, -1) - negative value for n(a[3] = {"Apple", "Banana", "Orange"}, 0) - zero value for n(a[3] = {"Apple", "Banana", "Orange"}, 1) - n less than size of array (no consecutive items)(a[3] = {"Apple", "Banana", "Orange"}, 3) - n equal to size of array(a[3] = {"Apple", "Banana", "Orange"}, 4) - n greater than size of array(a[0] = {}, 0) - empty array(a[1] = {"Apple"}, 1) - 1 value array(a[6] = {"Apple", "Apple", "Orange", "Banana", "Banana", "Banana"}, 6) - consecutive itemsint flip(string a[], int n)(a[3] = {"Apple", "Banana", "Orange"}, -1) - negative value for n(a[3] = {"Apple", "Banana", "Orange"}, 0) - zero value for n(a[3] = {"Apple", "Banana", "Orange"}, 1) - n less than size of array (no consecutive items)(a[3] = {"Apple", "Banana", "Orange"}, 3) - n equal to size of array(a[3] = {"Apple", "Banana", "Orange"}, 4) - n greater than size of array(a[0] = {}, 0) - empty array(a[1] = {"Apple"}, 1) - 1 value array(a[3] = {"", "", ""}, 2) - array of all empty strings(a[3] = {"Apple", "Banana", "Orange"}, 3) - odd amount of values(a[4] = {"Apple", "Banana", "Orange", "Tomato"}, 3) - even amount of valuesint differ(const string a1[], int n1, const string a2[], int n2)(a1[3] = {"AA", "BB", "CC"}, -1, a2[2] = {"DD", "EE"}, -1) - negative n1 and n2(a1[3] = {"AA", "BB", "CC"}, -1, a2[2] = {"DD", "EE"}, 1) - negative n1 only(a1[3] = {"AA", "BB", "CC"}, 1, a2[2] = {"DD", "EE"}, -1) - negative n2 only(a1[3] = {"AA", "BB", "CC"}, 0, a2[2] = {"DD", "EE"}, 0) - zero n1 and n2(a1[3] = {"AA", "BB", "CC"}, 0, a2[2] = {"DD", "EE"}, 1) - zero n1 only(a1[3] = {"AA", "BB", "CC"}, 1, a2[2] = {"DD", "EE"}, 0) - zero n2 only(a1[3] = {"AA", "BB", "CC"}, 2, a2[2] = {"DD", "EE"}, 2) - n1 = n2(a1[3] = {"AA", "BB", "CC"}, 3, a2[3] = {"DD", "EE", "FF"}, 2) - n1 > n2(a1[3] = {"AA", "BB", "CC"}, 2, a2[3] = {"DD", "EE", "FF"}, 3) - n1 < n2(a1[3] = {"AA", "BB", "CC"}, 3, a2[3] = {"AA", "BB", "CC"}, 3) - a1 = a2 and n1 = n2(a1[3] = {"AA", "BB", "CC"}, 3, a2[3] = {"Aa", "BB", "CC"}, 3) - first position not equal(a1[3] = {"AA", "BB", "CC"}, 3, a2[3] = {"AA", "BB", "Cc"}, 2) - equal to the point n2 runs out(a1[3] = {"AA", "BB", "CC"}, 3, a2[3] = {"Aa", "Bb", "Cc"}, 2) - completely unequalint subsequence(const string a1[], int n1, const string a2[], int n2)(a1[3] = {"AA", "BB", "CC"}, -1, a2[2] = {"DD", "EE"}, -1) - negative n1 and n2(a1[3] = {"AA", "BB", "CC"}, -1, a2[2] = {"DD", "EE"}, 1) - negative n1 only(a1[3] = {"AA", "BB", "CC"}, 1, a2[2] = {"DD", "EE"}, -1) - negative n2 only(a1[3] = {"AA", "BB", "CC"}, 0, a2[2] = {"DD", "EE"}, 0) - zero n1 and n2(a1[3] = {"AA", "BB", "CC"}, 0, a2[2] = {"DD", "EE"}, 1) - zero n1 only(a1[3] = {"AA", "BB", "CC"}, 1, a2[2] = {"DD", "EE"}, 0) - zero n2 only(a1[3] = {"AA", "BB", "CC"}, 2, a2[2] = {"DD", "EE"}, 2) - n1 = n2(a1[3] = {"AA", "BB", "CC"}, 3, a2[3] = {"DD", "EE", "FF"}, 2) - n1 > n2(a1[3] = {"AA", "BB", "CC"}, 2, a2[3] = {"DD", "EE", "FF"}, 3) - n1 < n2(a1[3] = {"AA", "BB", "CC"}, 3, a2[2] = {"BB", "CC"}, 2) - substring appears once(a1[6] = {"AA", "BB", "CC", "DD", "BB", "CC"}, 6, a2[2] = {"BB", "CC"}, 2) - substring appears multiple times(a1[6] = {"AA", "Bb", "Cc", "DD", "BB", "CC"}, 4, a2[2] = {"BB", "CC"}, 2) - substring appears outside n1(a1[6] = {"AA", "BB", "CC", "DD", "BB", "Cc"}, 6, a2[2] = {"BB", "CC"}, 2) - contains part of substringint lookupAny(const string a1[], int n1, const string a2[], int n2)(a1[3] = {"AA", "BB", "CC"}, -1, a2[2] = {"DD", "EE"}, -1) - negative n1 and n2(a1[3] = {"AA", "BB", "CC"}, -1, a2[2] = {"DD", "EE"}, 1) - negative n1 only(a1[3] = {"AA", "BB", "CC"}, 1, a2[2] = {"DD", "EE"}, -1) - negative n2 only(a1[3] = {"AA", "BB", "CC"}, 0, a2[2] = {"DD", "EE"}, 0) - zero n1 and n2(a1[3] = {"AA", "BB", "CC"}, 0, a2[2] = {"DD", "EE"}, 1) - zero n1 only(a1[3] = {"AA", "BB", "CC"}, 1, a2[2] = {"DD", "EE"}, 0) - zero n2 only(a1[3] = {"AA", "BB", "CC"}, 2, a2[2] = {"DD", "EE"}, 2) - n1 = n2(a1[3] = {"AA", "BB", "CC"}, 3, a2[3] = {"DD", "EE", "FF"}, 2) - n1 > n2(a1[3] = {"AA", "BB", "CC"}, 2, a2[3] = {"DD", "EE", "FF"}, 3) - n1 < n2(a1[3] = {"AA", "BB", "CC"}, 3, a2[2] = {"AA", "BB"}, 2) - all elements of n2 in n1(a1[3] = {"AA", "BB", "CC"}, 3, a2[2] = {"Aa", "BB"}, 2) - one element of n2 in n1(a1[3] = {"AA", "BB", "CC"}, 3, a2[2] = {"Aa", "BB"}, 1) - an element of a2 is in n1, but its position is outside of n2(a1[3] = {"AA", "BB", "CC"}, 2, a2[2] = {"Aa", "CC"}, 2) - an element of a2 is in a1, but its position in the first array is out of the range of n1int split(string a[], int n, string splitter)(a[3] = {"Apple", "Banana", "Orange"}, -1, "Peach") - negative value for n(a[3] = {"Apple", "Banana", "Orange"}, 0, "Peach") - negative value for n(a[3] = {"Apple", "Banana", "Orange"}, 1, "Peach") - n less than size of array(a[3] = {"Apple", "Banana", "Orange"}, 3, "Peach") - n equal to size of array(a[3] = {"Apple", "Banana", "Orange"}, 4, "Peach") - n greater than size of array(a[6]= {"AA", "BB", "CC", "DD", "EE", "FF"}, 6, "EE") - splitter = a value in the array(a[6]= {"Bb", "BB", "CC", "DD", "EE", "FF"}, 6, "AA") - splitter < all values in the array(a[6]= {"AA", "BB", "CC", "DD", "EE", "FF"}, 6, "ZZ") - splitter > all values in the array(a[6]= {"AA", "BB", "CC", "DD", "EE", "FF"}, 4, "Cc") - splitting a set of values < the size of the array(a[6]= {"AA", "BB", "CC", "DD", "EE", "FF"}, 6, "EE")(a[0] = {}, 0, "split") - empty array(a[1] = {"Apple"}, 1, "split") - 1 value array(a[3] = {"", "", ""}, 2, "split") - array of all empty strings